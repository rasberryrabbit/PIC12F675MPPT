program _12f675_MPPT;

{ 12F675 MPPT controller

  Copyright (C) 2015-2018 rasberryrabbit

  This source is free software; you can redistribute it and/or modify it under
  the terms of the GNU General Public License as published by the Free
  Software Foundation; either version 2 of the License, or MPL 1.1
  any later version.

  This code is distributed in the hope that it will be useful, but WITHOUT ANY
  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
  FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
  details.

  A copy of the GNU General Public License is available on the World Wide Web
  at <http://www.gnu.org/copyleft/gpl.html>. You can also obtain it by writing
  to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
  MA 02111-1307, USA.
}


{$define USE_EEPROM_LM358DIFF}
{$define Write_OPAMP_DIFF}

const
   PWM_MAX = 200;            // 190
   PWM_MIN = 2;              // 1 -> 2, for low load condition.
   PWM_MID = (PWM_MAX+PWM_MIN) div 2+10;

   TMR1L_LOAD=$18;
   TMR1H_LOAD=$FC;           // 4ms, 65536 - 1000

   VOLMUL = 25 div 6;        // 25V(1024) : 6A(1024), don't exceed 8
   _UPDATE_INT = 80 div 4;   // 80ms

   cLM358_diff = 0;
   adc_max_loop = 8;

label
   CONTLOOP;

var
   LED1:sbit at GP5_bit;
   PWM_SIG:sbit at GP0_bit;
   Write_OPAMP : sbit at GP3_bit;
   PWM_FLAG:bit;
   PWM_TICK, ON_PWM, VOL_PWM:byte;
   TICK_1000 : word;

   LED1_tm : byte;
   prevtime, powertime : word;
   adc_vol, adc_cur, vol_prev1, vol_prev2, cur_prev : word;
   power_prev, power_curr : dword;
   i, LM358_diff, power_flag : byte;
   flag_inc : boolean;
   wPWM, wTemp : word;

procedure Interrupt(); iv 0x0004; ics ICS_AUTO;
begin
     if T0IF_bit=1 then begin
       if PWM_FLAG=1 then begin
         PWM_SIG:=0;
         PWM_FLAG:=0;
         ON_PWM:=VOL_PWM;
         // on
         TMR0:=255-ON_PWM;
       end else begin
         // off
         TMR0:=255-PWM_MAX+ON_PWM;
         PWM_SIG:=1;
         PWM_FLAG:=1;
       end;
       T0IF_bit:=0;
     end;
end;

begin
     CMCON:=7;
     ANSEL:=%00111100;       // ADC conversion clock = fRC, AN3, AN2;

     TRISIO0_bit:=0;      // PWM
     TRISIO1_bit:=1;      // not Connected
     TRISIO2_bit:=1;      // AN2
     TRISIO4_bit:=1;      // AN3
     TRISIO5_bit:=0;      // LED

     LED1:=0;
     PWM_SIG:=1;
     PWM_FLAG:=1;
     LED1_tm:=250;
     ON_PWM:=0;
     VOL_PWM:=0;
     TICK_1000:=0;
     VCFG_bit:=1;
     CHS1_bit:=1;
     ADFM_bit:=1;

     OPTION_REG:=%01011111;        // ~4KHz @ 4MHz
     TMR0IE_bit:=1;
     
     LM358_diff:=cLM358_diff;
     Delay_10ms;
     {$ifdef Write_OPAMP_DIFF}
     if Write_OPAMP=0 then begin
       Delay_100ms;
       Delay_100ms;
       Delay_100ms;
       adc_cur:=ADC_Read(2);
       EEPROM_Write(0, Lo(adc_cur));
       Delay_100ms;
       LED1:=1;
       Delay_ms(700);
       LED1:=0;
     end;
     {$endif}

     {$ifdef USE_EEPROM_LM358DIFF}
     Delay_100ms;
     LM358_diff:=EEPROM_Read(0);
     {$endif}

     T1CKPS0_bit:=1;               // timer1 prescaler 1:2
     TMR1CS_bit:=0;
     TMR1L:=TMR1L_LOAD;
     TMR1H:=TMR1H_LOAD;
     T1IF_bit:=0;

     adc_vol:=0;
     adc_cur:=0;
     power_curr:=0;

     GIE_bit:=1;                   // enable Interrupt

     TMR1ON_bit:=1;

     VOL_PWM:=PWM_MID;
     flag_inc:=False;
     cur_prev:=0;
     vol_prev1:=0;

     powertime:=0;
     prevtime:=0;

     while True do begin
       // Timer - 4ms
       if T1IF_bit=1 then begin
         TMR1H:=TMR1H_LOAD;
         TMR1L:=TMR1L_LOAD;
         T1IF_bit:=0;
         Inc(TICK_1000);
       end;
       // LED
       wPWM := TICK_1000;
       if wPWM - prevtime > LED1_tm then begin
         prevtime := TICK_1000;
         LED1 := not LED1;
       end;

       // save previous adc values
       cur_prev:=adc_cur;
       vol_prev2:=vol_prev1;
       vol_prev1:=adc_vol;
       // read adc value
       adc_vol:=0;
       adc_cur:=0;
       for i:=0 to adc_max_loop-1 do begin
         wPWM:=ADC_Read(3);
         wTemp:=ADC_Read(2);
         adc_vol:=adc_vol+wPWM;
         adc_cur:=adc_cur+wTemp;
       end;
       adc_vol:=adc_vol div adc_max_loop;
       adc_cur:=adc_cur div adc_max_loop;
       adc_vol:=adc_vol * VOLMUL;

       // check time
       wPWM:=TICK_1000;
       if wPWM - powertime < _UPDATE_INT then
         goto CONTLOOP;
       powertime:=TICK_1000;

       power_prev:=power_curr;
       power_curr:= adc_vol * adc_cur;

       if adc_cur>LM358_diff then begin
         // power check
         if power_curr = power_prev then begin
           LED1_tm:=125;
           goto CONTLOOP;
         end else if power_curr > power_prev then begin
           LED1_tm:=100;
         end else begin
           LED1_tm:=75;
           flag_inc:=not flag_inc;
         end;
         if (adc_vol+vol_prev2+1) div 2 < vol_prev1 then
           flag_inc:=true;
       end else begin
         LED1_tm:=75;
         VOL_PWM:=PWM_MID;
         flag_inc:=false;
         power_curr:=0;
         adc_cur:=0;
         power_flag:=0;
         goto CONTLOOP;
       end;

       // PWM
       if flag_inc then begin
         if VOL_PWM<PWM_MAX then
           Inc(VOL_PWM)
           else begin
             VOL_PWM:=PWM_MAX;
             flag_inc:=false;
           end;
       end else begin
         if VOL_PWM>PWM_MIN then
           Dec(VOL_PWM)
           else begin
             VOL_PWM:=PWM_MIN;
             flag_inc:=true;
           end;
       end;
CONTLOOP:
     end;
end.